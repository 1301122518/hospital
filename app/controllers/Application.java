package controllers;

import java.util.Set;

import models.Patient;
import models.PatientRepository;
import models.Department;
import models.DepartmentRepository;
import play.mvc.*;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;

/**
 * The main set of web services.
 */
@Named
@Singleton
public class Application extends Controller {

    private final PatientRepository patientRepository;
    private final DepartmentRepository departmentRepository;

    // We are using constructor injection to receive a repository to support our desire for immutability.
    @Inject
    public Application(final PatientRepository patientRepository, final DepartmentRepository departmentRepository) {
        this.patientRepository = patientRepository;
        this.departmentRepository = departmentRepository;
    }

    public Result index() {

        // For fun we save a new person and then find that one we've just saved. The id is auto generated by
        // the db so we know that we're round-tripping to the db and back in order to demonstrate something
        // interesting. Spring Data takes care of transactional concerns and the following code is all
        // executed on the same thread (a requirement of the JPA entity manager).

        final Patient patient = new Patient();
        patient.id = 1L;
        patient.name = "Ling";

//        final Patient savedPatient = patientRepository.save(patient);

        final Patient retrievedPatient = patientRepository.findOne(patient.id);
        final Department department = departmentRepository.findOne(1L);
        final Set<Department> departments = retrievedPatient.departments;

//        Integer number = departments.size();
        // Deliver the index page with a message showing the id that was generated.

        return ok(views.html.index.render("Found id: " + retrievedPatient.id + retrievedPatient.name + department.name +  " of person/people"));
    }
}
